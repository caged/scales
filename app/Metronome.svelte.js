/* src/app/Metronome.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_input_value,
	space,
	svg_element,
	to_number,
	toggle_class,
	transition_in,
	transition_out
} from "../_snowpack/pkg/svelte/internal.js";

import { Howl } from "../_snowpack/pkg/howler.js";
import { delay } from "./utils.js";
import Volume from "./Volume.svelte.js";
import { bpm } from "./store.js";

function create_fragment(ctx) {
	let div3;
	let div0;
	let input;
	let input_min_value;
	let input_max_value;
	let t0;
	let label;
	let t2;
	let div2;
	let svg;
	let path;
	let t3;
	let div1;
	let volume_1;
	let updating_volume;
	let current;
	let mounted;
	let dispose;

	function volume_1_volume_binding(value) {
		/*volume_1_volume_binding*/ ctx[5](value);
	}

	let volume_1_props = {};

	if (/*volume*/ ctx[0] !== void 0) {
		volume_1_props.volume = /*volume*/ ctx[0];
	}

	volume_1 = new Volume({ props: volume_1_props });
	binding_callbacks.push(() => bind(volume_1, 'volume', volume_1_volume_binding));

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			input = element("input");
			t0 = space();
			label = element("label");
			label.textContent = "BPM";
			t2 = space();
			div2 = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			t3 = space();
			div1 = element("div");
			create_component(volume_1.$$.fragment);
			attr(input, "type", "number");
			attr(input, "min", input_min_value = 10);
			attr(input, "max", input_max_value = 300);
			attr(input, "class", "p-0 m-0 w-auto appearance-none border-none text-4xl text-gray-800");
			attr(label, "for", "bmp");
			attr(label, "class", "text-sm ml-1 text-gray-500");
			attr(div0, "class", "flex items-center justify-center mx-auto mb-1");
			attr(path, "stroke-linecap", "round");
			attr(path, "stroke-linejoin", "round");
			attr(path, "stroke-width", "2");
			attr(path, "d", "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
			attr(svg, "class", "w-6 h-6");
			toggle_class(svg, "text-green-500", /*playing*/ ctx[2]);
			attr(div2, "class", "flex items-center space-x-2");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			append(div0, input);
			set_input_value(input, /*$bpm*/ ctx[1]);
			append(div0, t0);
			append(div0, label);
			append(div3, t2);
			append(div3, div2);
			append(div2, svg);
			append(svg, path);
			append(div2, t3);
			append(div2, div1);
			mount_component(volume_1, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[4]),
					listen(svg, "click", /*play*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$bpm*/ 2 && to_number(input.value) !== /*$bpm*/ ctx[1]) {
				set_input_value(input, /*$bpm*/ ctx[1]);
			}

			if (dirty & /*playing*/ 4) {
				toggle_class(svg, "text-green-500", /*playing*/ ctx[2]);
			}

			const volume_1_changes = {};

			if (!updating_volume && dirty & /*volume*/ 1) {
				updating_volume = true;
				volume_1_changes.volume = /*volume*/ ctx[0];
				add_flush_callback(() => updating_volume = false);
			}

			volume_1.$set(volume_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(volume_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(volume_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			destroy_component(volume_1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $bpm;
	component_subscribe($$self, bpm, $$value => $$invalidate(1, $bpm = $$value));
	let volume = 0.5;
	let playing = false;

	var sound = new Howl({
			src: "metronome.mp3",
			sprite: {
				a: [0, 500],
				b: [500, 500],
				c: [1000, 500],
				d: [1500, 500]
			}
		});

	async function play(event) {
		$$invalidate(2, playing = !playing);

		while (!!playing) {
			sound.play("d");
			await delay(60 / $bpm * 1000);
		}
	}

	function input_input_handler() {
		$bpm = to_number(this.value);
		bpm.set($bpm);
	}

	function volume_1_volume_binding(value) {
		volume = value;
		$$invalidate(0, volume);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*volume*/ 1) {
			$: sound.volume(volume);
		}

		if ($$self.$$.dirty & /*$bpm*/ 2) {
			$: bpm.set($bpm);
		}
	};

	return [volume, $bpm, playing, play, input_input_handler, volume_1_volume_binding];
}

class Metronome extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Metronome;