/* src/app/App.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../_snowpack/pkg/svelte/internal.js";

import { Chord, Note } from "../_snowpack/pkg/@tonaljs/tonal.js";
import { scale as getScale, tnps, pentatonic } from "../frets/index.js";
import KeySelector from "./KeySelector.svelte.js";
import ScaleSelector from "./ScaleSelector.svelte.js";
import FretBoard from "./FretBoard.svelte.js";
import ScaleInfo from "./ScaleInfo.svelte.js";
import PositionSelector from "./PositionSelector.svelte.js";
import TuningSelector from "./TuningSelector.svelte.js";
import ScaleChords from "./ScaleChords.svelte.js";
import NotePlayer from "./NotePlayer.svelte.js";
import AppContext from "./AppContext.svelte.js";
import Metronome from "./Metronome.svelte.js";
import { tonic, tuning } from "./store.js";

function create_if_block(ctx) {
	let div4;
	let div1;
	let div0;
	let h1;
	let span0;
	let t0_value = /*$tonic*/ ctx[3].replace("b", "♭") + "";
	let t0;
	let t1;
	let span1;
	let t2;
	let t3;
	let t4;
	let t5;
	let div2;
	let h30;
	let t7;
	let scaleinfo;
	let updating_scale;
	let updating_position;
	let t8;
	let div3;
	let h31;
	let t10;
	let scalechords;
	let current;
	let if_block = /*aliases*/ ctx[7].length > 0 && create_if_block_1(ctx);

	function scaleinfo_scale_binding(value) {
		/*scaleinfo_scale_binding*/ ctx[14](value);
	}

	function scaleinfo_position_binding(value) {
		/*scaleinfo_position_binding*/ ctx[15](value);
	}

	let scaleinfo_props = {};

	if (/*scale*/ ctx[1] !== void 0) {
		scaleinfo_props.scale = /*scale*/ ctx[1];
	}

	if (/*position*/ ctx[5] !== void 0) {
		scaleinfo_props.position = /*position*/ ctx[5];
	}

	scaleinfo = new ScaleInfo({ props: scaleinfo_props });
	binding_callbacks.push(() => bind(scaleinfo, 'scale', scaleinfo_scale_binding));
	binding_callbacks.push(() => bind(scaleinfo, 'position', scaleinfo_position_binding));
	scalechords = new ScaleChords({ props: { scale: /*scale*/ ctx[1] } });
	scalechords.$on("chordchange", /*handleChordChange*/ ctx[9]);

	return {
		c() {
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			h1 = element("h1");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			span1 = element("span");
			t2 = text(/*scaleLabel*/ ctx[0]);
			t3 = text(" scale");
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			div2 = element("div");
			h30 = element("h3");
			h30.textContent = "Notes and intervals";
			t7 = space();
			create_component(scaleinfo.$$.fragment);
			t8 = space();
			div3 = element("div");
			h31 = element("h3");
			h31.textContent = "Chords";
			t10 = space();
			create_component(scalechords.$$.fragment);
			attr(span0, "class", "underline");
			attr(h1, "class", "text-3xl font-bold i capitalize");
			attr(div1, "class", "p-5 flex w-1/5 md:w-1/3");
			attr(h30, "class", "font-bold");
			attr(div2, "class", "w-1/2 p-5");
			attr(h31, "class", "font-bold");
			attr(div3, "class", "p-5 hidden lg:block w-2/3");
			attr(div4, "class", "flex border-b border-gray-200 bg-gray-50 space-x-10");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div1);
			append(div1, div0);
			append(div0, h1);
			append(h1, span0);
			append(span0, t0);
			append(h1, t1);
			append(h1, span1);
			append(span1, t2);
			append(span1, t3);
			append(div0, t4);
			if (if_block) if_block.m(div0, null);
			append(div4, t5);
			append(div4, div2);
			append(div2, h30);
			append(div2, t7);
			mount_component(scaleinfo, div2, null);
			append(div4, t8);
			append(div4, div3);
			append(div3, h31);
			append(div3, t10);
			mount_component(scalechords, div3, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$tonic*/ 8) && t0_value !== (t0_value = /*$tonic*/ ctx[3].replace("b", "♭") + "")) set_data(t0, t0_value);
			if (!current || dirty & /*scaleLabel*/ 1) set_data(t2, /*scaleLabel*/ ctx[0]);

			if (/*aliases*/ ctx[7].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const scaleinfo_changes = {};

			if (!updating_scale && dirty & /*scale*/ 2) {
				updating_scale = true;
				scaleinfo_changes.scale = /*scale*/ ctx[1];
				add_flush_callback(() => updating_scale = false);
			}

			if (!updating_position && dirty & /*position*/ 32) {
				updating_position = true;
				scaleinfo_changes.position = /*position*/ ctx[5];
				add_flush_callback(() => updating_position = false);
			}

			scaleinfo.$set(scaleinfo_changes);
			const scalechords_changes = {};
			if (dirty & /*scale*/ 2) scalechords_changes.scale = /*scale*/ ctx[1];
			scalechords.$set(scalechords_changes);
		},
		i(local) {
			if (current) return;
			transition_in(scaleinfo.$$.fragment, local);
			transition_in(scalechords.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scaleinfo.$$.fragment, local);
			transition_out(scalechords.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			if (if_block) if_block.d();
			destroy_component(scaleinfo);
			destroy_component(scalechords);
		}
	};
}

// (82:12) {#if aliases.length > 0}
function create_if_block_1(ctx) {
	let span1;
	let t0;
	let span0;
	let t1;

	return {
		c() {
			span1 = element("span");
			t0 = text("Also known as\n                ");
			span0 = element("span");
			t1 = text(/*aliases*/ ctx[7]);
			attr(span0, "class", "capitalize");
			attr(span1, "class", "text-sm text-gray-400");
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			append(span1, t0);
			append(span1, span0);
			append(span0, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*aliases*/ 128) set_data(t1, /*aliases*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(span1);
		}
	};
}

// (43:0) <AppContext>
function create_default_slot(ctx) {
	let div7;
	let div0;
	let h30;
	let t1;
	let tuningselector;
	let t2;
	let div2;
	let h31;
	let t4;
	let div1;
	let keyselector;
	let t5;
	let div4;
	let h32;
	let t7;
	let div3;
	let scaleselector;
	let updating_value;
	let t8;
	let div5;
	let h33;
	let t10;
	let positionselector;
	let updating_position;
	let t11;
	let div6;
	let metronome;
	let t12;
	let div9;
	let t13;
	let div8;
	let fretboard;
	let updating_scale;
	let updating_system;
	let updating_position_1;
	let updating_notes;
	let t14;
	let noteplayer;
	let updating_notes_1;
	let current;

	tuningselector = new TuningSelector({
			props: { defaultTuning: /*$tuning*/ ctx[4] }
		});

	keyselector = new KeySelector({ props: { key: /*$tonic*/ ctx[3] } });

	function scaleselector_value_binding(value) {
		/*scaleselector_value_binding*/ ctx[12](value);
	}

	let scaleselector_props = {};

	if (/*scaleLabel*/ ctx[0] !== void 0) {
		scaleselector_props.value = /*scaleLabel*/ ctx[0];
	}

	scaleselector = new ScaleSelector({ props: scaleselector_props });
	binding_callbacks.push(() => bind(scaleselector, 'value', scaleselector_value_binding));

	function positionselector_position_binding(value) {
		/*positionselector_position_binding*/ ctx[13](value);
	}

	let positionselector_props = { scale: /*scale*/ ctx[1] };

	if (/*position*/ ctx[5] !== void 0) {
		positionselector_props.position = /*position*/ ctx[5];
	}

	positionselector = new PositionSelector({ props: positionselector_props });
	binding_callbacks.push(() => bind(positionselector, 'position', positionselector_position_binding));
	metronome = new Metronome({});
	let if_block = /*scaleLabel*/ ctx[0] != "" && create_if_block(ctx);

	function fretboard_scale_binding(value) {
		/*fretboard_scale_binding*/ ctx[16](value);
	}

	function fretboard_system_binding(value) {
		/*fretboard_system_binding*/ ctx[17](value);
	}

	function fretboard_position_binding(value) {
		/*fretboard_position_binding*/ ctx[18](value);
	}

	function fretboard_notes_binding(value) {
		/*fretboard_notes_binding*/ ctx[19](value);
	}

	let fretboard_props = { tuning: /*$tuning*/ ctx[4] };

	if (/*scale*/ ctx[1] !== void 0) {
		fretboard_props.scale = /*scale*/ ctx[1];
	}

	if (/*system*/ ctx[8] !== void 0) {
		fretboard_props.system = /*system*/ ctx[8];
	}

	if (/*position*/ ctx[5] !== void 0) {
		fretboard_props.position = /*position*/ ctx[5];
	}

	if (/*notes*/ ctx[6] !== void 0) {
		fretboard_props.notes = /*notes*/ ctx[6];
	}

	fretboard = new FretBoard({ props: fretboard_props });
	binding_callbacks.push(() => bind(fretboard, 'scale', fretboard_scale_binding));
	binding_callbacks.push(() => bind(fretboard, 'system', fretboard_system_binding));
	binding_callbacks.push(() => bind(fretboard, 'position', fretboard_position_binding));
	binding_callbacks.push(() => bind(fretboard, 'notes', fretboard_notes_binding));

	function noteplayer_notes_binding(value) {
		/*noteplayer_notes_binding*/ ctx[20](value);
	}

	let noteplayer_props = {};

	if (/*notes*/ ctx[6] !== void 0) {
		noteplayer_props.notes = /*notes*/ ctx[6];
	}

	noteplayer = new NotePlayer({ props: noteplayer_props });
	binding_callbacks.push(() => bind(noteplayer, 'notes', noteplayer_notes_binding));

	return {
		c() {
			div7 = element("div");
			div0 = element("div");
			h30 = element("h3");
			h30.textContent = "Tuning";
			t1 = space();
			create_component(tuningselector.$$.fragment);
			t2 = space();
			div2 = element("div");
			h31 = element("h3");
			h31.textContent = "Key";
			t4 = space();
			div1 = element("div");
			create_component(keyselector.$$.fragment);
			t5 = space();
			div4 = element("div");
			h32 = element("h3");
			h32.textContent = "Scale";
			t7 = space();
			div3 = element("div");
			create_component(scaleselector.$$.fragment);
			t8 = space();
			div5 = element("div");
			h33 = element("h3");
			h33.textContent = "Position";
			t10 = space();
			create_component(positionselector.$$.fragment);
			t11 = space();
			div6 = element("div");
			create_component(metronome.$$.fragment);
			t12 = space();
			div9 = element("div");
			if (if_block) if_block.c();
			t13 = space();
			div8 = element("div");
			create_component(fretboard.$$.fragment);
			t14 = space();
			create_component(noteplayer.$$.fragment);
			attr(h30, "class", "mb-2 font-bold");
			attr(div0, "class", "p-5 w-1/2 md:w-auto border-r border-b sm:border-b-0 border-gray-200");
			attr(h31, "class", "mb-2 font-bold");
			attr(div2, "class", "p-5 w-1/2 md:w-auto border-r border-b sm:border-b-0 border-gray-200");
			attr(h32, "class", "font-bold mb-2");
			attr(div4, "class", "p-5 pb-6 w-1/2 md:w-96 border-r border-b sm:border-b-0 border-gray-200");
			attr(h33, "class", "mb-2 font-bold");
			attr(div5, "class", "p-5 w-1/2 md:w-auto border-r border-b sm:border-b-0 border-gray-200");
			attr(div6, "class", "p-5 w-1/2 md:w-auto border-r border-gray-200");
			attr(div7, "class", "flex flex-wrap md:flex-nowrap border-b border-gray-300");
			attr(div8, "class", "py-10");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, div0);
			append(div0, h30);
			append(div0, t1);
			mount_component(tuningselector, div0, null);
			append(div7, t2);
			append(div7, div2);
			append(div2, h31);
			append(div2, t4);
			append(div2, div1);
			mount_component(keyselector, div1, null);
			append(div7, t5);
			append(div7, div4);
			append(div4, h32);
			append(div4, t7);
			append(div4, div3);
			mount_component(scaleselector, div3, null);
			append(div7, t8);
			append(div7, div5);
			append(div5, h33);
			append(div5, t10);
			mount_component(positionselector, div5, null);
			append(div7, t11);
			append(div7, div6);
			mount_component(metronome, div6, null);
			insert(target, t12, anchor);
			insert(target, div9, anchor);
			if (if_block) if_block.m(div9, null);
			append(div9, t13);
			append(div9, div8);
			mount_component(fretboard, div8, null);
			append(div9, t14);
			mount_component(noteplayer, div9, null);
			current = true;
		},
		p(ctx, dirty) {
			const tuningselector_changes = {};
			if (dirty & /*$tuning*/ 16) tuningselector_changes.defaultTuning = /*$tuning*/ ctx[4];
			tuningselector.$set(tuningselector_changes);
			const keyselector_changes = {};
			if (dirty & /*$tonic*/ 8) keyselector_changes.key = /*$tonic*/ ctx[3];
			keyselector.$set(keyselector_changes);
			const scaleselector_changes = {};

			if (!updating_value && dirty & /*scaleLabel*/ 1) {
				updating_value = true;
				scaleselector_changes.value = /*scaleLabel*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			scaleselector.$set(scaleselector_changes);
			const positionselector_changes = {};
			if (dirty & /*scale*/ 2) positionselector_changes.scale = /*scale*/ ctx[1];

			if (!updating_position && dirty & /*position*/ 32) {
				updating_position = true;
				positionselector_changes.position = /*position*/ ctx[5];
				add_flush_callback(() => updating_position = false);
			}

			positionselector.$set(positionselector_changes);

			if (/*scaleLabel*/ ctx[0] != "") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*scaleLabel*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div9, t13);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const fretboard_changes = {};
			if (dirty & /*$tuning*/ 16) fretboard_changes.tuning = /*$tuning*/ ctx[4];

			if (!updating_scale && dirty & /*scale*/ 2) {
				updating_scale = true;
				fretboard_changes.scale = /*scale*/ ctx[1];
				add_flush_callback(() => updating_scale = false);
			}

			if (!updating_system && dirty & /*system*/ 256) {
				updating_system = true;
				fretboard_changes.system = /*system*/ ctx[8];
				add_flush_callback(() => updating_system = false);
			}

			if (!updating_position_1 && dirty & /*position*/ 32) {
				updating_position_1 = true;
				fretboard_changes.position = /*position*/ ctx[5];
				add_flush_callback(() => updating_position_1 = false);
			}

			if (!updating_notes && dirty & /*notes*/ 64) {
				updating_notes = true;
				fretboard_changes.notes = /*notes*/ ctx[6];
				add_flush_callback(() => updating_notes = false);
			}

			fretboard.$set(fretboard_changes);
			const noteplayer_changes = {};

			if (!updating_notes_1 && dirty & /*notes*/ 64) {
				updating_notes_1 = true;
				noteplayer_changes.notes = /*notes*/ ctx[6];
				add_flush_callback(() => updating_notes_1 = false);
			}

			noteplayer.$set(noteplayer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tuningselector.$$.fragment, local);
			transition_in(keyselector.$$.fragment, local);
			transition_in(scaleselector.$$.fragment, local);
			transition_in(positionselector.$$.fragment, local);
			transition_in(metronome.$$.fragment, local);
			transition_in(if_block);
			transition_in(fretboard.$$.fragment, local);
			transition_in(noteplayer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tuningselector.$$.fragment, local);
			transition_out(keyselector.$$.fragment, local);
			transition_out(scaleselector.$$.fragment, local);
			transition_out(positionselector.$$.fragment, local);
			transition_out(metronome.$$.fragment, local);
			transition_out(if_block);
			transition_out(fretboard.$$.fragment, local);
			transition_out(noteplayer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div7);
			destroy_component(tuningselector);
			destroy_component(keyselector);
			destroy_component(scaleselector);
			destroy_component(positionselector);
			destroy_component(metronome);
			if (detaching) detach(t12);
			if (detaching) detach(div9);
			if (if_block) if_block.d();
			destroy_component(fretboard);
			destroy_component(noteplayer);
		}
	};
}

function create_fragment(ctx) {
	let title_value;
	let meta;
	let meta_content_value;
	let html;
	let t;
	let appcontext;
	let current;
	document.title = title_value = /*scaleName*/ ctx[2];

	appcontext = new AppContext({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			meta = element("meta");
			html = element("html");
			t = space();
			create_component(appcontext.$$.fragment);
			attr(meta, "name", "Description");
			attr(meta, "content", meta_content_value = "" + (/*scaleName*/ ctx[2] + " guitar scale"));
			attr(html, "lang", "en");
		},
		m(target, anchor) {
			append(document.head, meta);
			append(document.head, html);
			insert(target, t, anchor);
			mount_component(appcontext, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*scaleName*/ 4) && title_value !== (title_value = /*scaleName*/ ctx[2])) {
				document.title = title_value;
			}

			if (!current || dirty & /*scaleName*/ 4 && meta_content_value !== (meta_content_value = "" + (/*scaleName*/ ctx[2] + " guitar scale"))) {
				attr(meta, "content", meta_content_value);
			}

			const appcontext_changes = {};

			if (dirty & /*$$scope, notes, $tuning, scale, system, position, aliases, scaleLabel, $tonic*/ 2097659) {
				appcontext_changes.$$scope = { dirty, ctx };
			}

			appcontext.$set(appcontext_changes);
		},
		i(local) {
			if (current) return;
			transition_in(appcontext.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(appcontext.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			detach(meta);
			detach(html);
			if (detaching) detach(t);
			destroy_component(appcontext, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let scaleName;
	let scale;
	let system;
	let aliases;
	let chord;
	let notes;
	let $tonic;
	let $tuning;
	component_subscribe($$self, tonic, $$value => $$invalidate(3, $tonic = $$value));
	component_subscribe($$self, tuning, $$value => $$invalidate(4, $tuning = $$value));
	let scaleLabel = "aeolian";
	let position;
	let chordName;

	function handleChordChange(event) {
		$$invalidate(10, chordName = event.detail);
	}

	function scaleselector_value_binding(value) {
		scaleLabel = value;
		$$invalidate(0, scaleLabel);
	}

	function positionselector_position_binding(value) {
		position = value;
		$$invalidate(5, position);
	}

	function scaleinfo_scale_binding(value) {
		scale = value;
		((($$invalidate(1, scale), $$invalidate(2, scaleName)), $$invalidate(3, $tonic)), $$invalidate(0, scaleLabel));
	}

	function scaleinfo_position_binding(value) {
		position = value;
		$$invalidate(5, position);
	}

	function fretboard_scale_binding(value) {
		scale = value;
		((($$invalidate(1, scale), $$invalidate(2, scaleName)), $$invalidate(3, $tonic)), $$invalidate(0, scaleLabel));
	}

	function fretboard_system_binding(value) {
		system = value;
		(((($$invalidate(8, system), $$invalidate(1, scale)), $$invalidate(2, scaleName)), $$invalidate(3, $tonic)), $$invalidate(0, scaleLabel));
	}

	function fretboard_position_binding(value) {
		position = value;
		$$invalidate(5, position);
	}

	function fretboard_notes_binding(value) {
		notes = value;
		(((($$invalidate(6, notes), $$invalidate(11, chord)), $$invalidate(10, chordName)), $$invalidate(4, $tuning)), $$invalidate(3, $tonic));
	}

	function noteplayer_notes_binding(value) {
		notes = value;
		(((($$invalidate(6, notes), $$invalidate(11, chord)), $$invalidate(10, chordName)), $$invalidate(4, $tuning)), $$invalidate(3, $tonic));
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$tonic, scaleLabel*/ 9) {
			$: $$invalidate(2, scaleName = `${$tonic} ${scaleLabel}`);
		}

		if ($$self.$$.dirty & /*scaleName*/ 4) {
			$: $$invalidate(1, scale = getScale(scaleName));
		}

		if ($$self.$$.dirty & /*scale*/ 2) {
			$: $$invalidate(8, system = scale.intervals().length === 5 ? pentatonic : tnps);
		}

		if ($$self.$$.dirty & /*scale*/ 2) {
			$: $$invalidate(7, aliases = scale.aliases());
		}

		if ($$self.$$.dirty & /*chordName, $tuning, $tonic*/ 1048) {
			$: $$invalidate(11, chord = Chord.getChord(chordName, Note.get($tuning[0]).height > Note.get(`${$tonic}2`).height
			? `${$tonic}3`
			: `${$tonic}2`));
		}

		if ($$self.$$.dirty & /*chord*/ 2048) {
			$: $$invalidate(6, notes = chord.notes.map(Note.get));
		}
	};

	return [
		scaleLabel,
		scale,
		scaleName,
		$tonic,
		$tuning,
		position,
		notes,
		aliases,
		system,
		handleChordChange,
		chordName,
		chord,
		scaleselector_value_binding,
		positionselector_position_binding,
		scaleinfo_scale_binding,
		scaleinfo_position_binding,
		fretboard_scale_binding,
		fretboard_system_binding,
		fretboard_position_binding,
		fretboard_notes_binding,
		noteplayer_notes_binding
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;