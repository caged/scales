/* src/app/KeySelector.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	select_option,
	select_value,
	space,
	text
} from "../_snowpack/pkg/svelte/internal.js";

import { tonic } from "./store.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (21:6) {#each notes as note}
function create_each_block(ctx) {
	let option;
	let t_value = /*note*/ ctx[1] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*note*/ ctx[1];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment(ctx) {
	let div3;
	let div0;
	let select;
	let t0;
	let div1;
	let input0;
	let t1;
	let span0;
	let t3;
	let div2;
	let input1;
	let t4;
	let span1;
	let mounted;
	let dispose;
	let each_value = /*notes*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div1 = element("div");
			input0 = element("input");
			t1 = space();
			span0 = element("span");
			span0.textContent = "â™­";
			t3 = space();
			div2 = element("div");
			input1 = element("input");
			t4 = space();
			span1 = element("span");
			span1.textContent = "#";
			attr(select, "name", "note");
			attr(select, "class", "rounded-lg border-gray-300");
			if (/*note*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[5].call(select));
			attr(input0, "type", "radio");
			input0.__value = "b";
			input0.value = input0.__value;
			attr(input0, "class", "mr-1");
			/*$$binding_groups*/ ctx[7][0].push(input0);
			attr(span0, "class", "text-2xl");
			attr(div1, "class", "flex items-center");
			attr(input1, "type", "radio");
			input1.__value = "#";
			input1.value = input1.__value;
			attr(input1, "class", "mr-1");
			/*$$binding_groups*/ ctx[7][0].push(input1);
			attr(div2, "class", "flex items-center");
			attr(div3, "class", "flex items-center space-x-5");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			append(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*note*/ ctx[1]);
			append(div3, t0);
			append(div3, div1);
			append(div1, input0);
			input0.checked = input0.__value === /*modifier*/ ctx[0];
			append(div1, t1);
			append(div1, span0);
			append(div3, t3);
			append(div3, div2);
			append(div2, input1);
			input1.checked = input1.__value === /*modifier*/ ctx[0];
			append(div2, t4);
			append(div2, span1);

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[5]),
					listen(input0, "change", /*input0_change_handler*/ ctx[6]),
					listen(input0, "click", /*toggleEnabled*/ ctx[3]),
					listen(input1, "change", /*input1_change_handler*/ ctx[8]),
					listen(input1, "click", /*toggleEnabled*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*notes*/ 4) {
				each_value = /*notes*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*note, notes*/ 6) {
				select_option(select, /*note*/ ctx[1]);
			}

			if (dirty & /*modifier*/ 1) {
				input0.checked = input0.__value === /*modifier*/ ctx[0];
			}

			if (dirty & /*modifier*/ 1) {
				input1.checked = input1.__value === /*modifier*/ ctx[0];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div3);
			destroy_each(each_blocks, detaching);
			/*$$binding_groups*/ ctx[7][0].splice(/*$$binding_groups*/ ctx[7][0].indexOf(input0), 1);
			/*$$binding_groups*/ ctx[7][0].splice(/*$$binding_groups*/ ctx[7][0].indexOf(input1), 1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { key } = $$props;
	let note = key;
	let modifier = null;
	const notes = ["E", "F", "G", "A", "B", "C", "D"];

	function toggleEnabled(event) {
		if (modifier === event.target.value) $$invalidate(0, modifier = null);
	}

	const $$binding_groups = [[]];

	function select_change_handler() {
		note = select_value(this);
		$$invalidate(1, note);
		$$invalidate(2, notes);
	}

	function input0_change_handler() {
		modifier = this.__value;
		$$invalidate(0, modifier);
	}

	function input1_change_handler() {
		modifier = this.__value;
		$$invalidate(0, modifier);
	}

	$$self.$$set = $$props => {
		if ('key' in $$props) $$invalidate(4, key = $$props.key);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*note, modifier*/ 3) {
			$: $$invalidate(4, key = [note, modifier].join(""));
		}

		if ($$self.$$.dirty & /*key*/ 16) {
			$: tonic.set(key);
		}
	};

	return [
		modifier,
		note,
		notes,
		toggleEnabled,
		key,
		select_change_handler,
		input0_change_handler,
		$$binding_groups,
		input1_change_handler
	];
}

class KeySelector extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { key: 4 });
	}
}

export default KeySelector;