import './FretBoard.svelte.css.proxy.js';
/* src/app/FretBoard.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	null_to_empty,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text
} from "../_snowpack/pkg/svelte/internal.js";

import { getContext } from "../_snowpack/pkg/svelte.js";
import { scaleBand, scalePoint, scaleLinear, range } from "../_snowpack/pkg/d3.js";
import { frets, tnps } from "../frets/index.js";
import { delay } from "./utils.js";
import { bpm } from "./store.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

// (122:12) {#if j > 0}
function create_if_block_1(ctx) {
	let show_if;
	let show_if_1;
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (dirty & /*position, strings*/ 17) show_if = null;
		if (dirty & /*strings, position*/ 17) show_if_1 = null;
		if (show_if == null) show_if = !!(!/*position*/ ctx[0] || /*noteInPosition*/ ctx[10](/*note*/ ctx[26], /*position*/ ctx[0]));
		if (show_if) return create_if_block_2;
		if (show_if_1 == null) show_if_1 = !!(/*noteInPosition*/ ctx[10](/*note*/ ctx[26], /*position*/ ctx[0] === 7 ? 1 : /*position*/ ctx[0] + 1) || /*noteInPosition*/ ctx[10](/*note*/ ctx[26], /*position*/ ctx[0] === 1 ? 7 : /*position*/ ctx[0] - 1));
		if (show_if_1) return create_if_block_3;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (129:139) 
function create_if_block_3(ctx) {
	let circle;

	return {
		c() {
			circle = svg_element("circle");
			attr(circle, "r", "10");
			attr(circle, "fill", "currentColor");
			attr(circle, "class", "text-gray-200");
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (123:14) {#if !position || noteInPosition(note, position)}
function create_if_block_2(ctx) {
	let circle;
	let circle_class_value;

	return {
		c() {
			circle = svg_element("circle");
			attr(circle, "r", "10");
			attr(circle, "fill", "currentColor");
			attr(circle, "class", circle_class_value = "" + (null_to_empty(/*classesForNote*/ ctx[11](/*note*/ ctx[26], /*notes*/ ctx[1])) + " svelte-1hi8vhn"));
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*strings, notes*/ 18 && circle_class_value !== (circle_class_value = "" + (null_to_empty(/*classesForNote*/ ctx[11](/*note*/ ctx[26], /*notes*/ ctx[1])) + " svelte-1hi8vhn"))) {
				attr(circle, "class", circle_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (120:8) {#each str as note, j}
function create_each_block_2(ctx) {
	let g;
	let text_1;
	let t_value = /*note*/ ctx[26].pc.replace("b", "♭") + "";
	let t;
	let text_1_class_value;
	let g_transform_value;
	let mounted;
	let dispose;
	let if_block = /*j*/ ctx[28] > 0 && create_if_block_1(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[18](/*note*/ ctx[26]);
	}

	return {
		c() {
			g = svg_element("g");
			if (if_block) if_block.c();
			text_1 = svg_element("text");
			t = text(t_value);
			attr(text_1, "dy", "1");

			attr(text_1, "class", text_1_class_value = "" + ((/*note*/ ctx[26].interval && !/*position*/ ctx[0] || /*noteInPosition*/ ctx[10](/*note*/ ctx[26], /*position*/ ctx[0])
			? /*j*/ ctx[28] == 0 ? 'text-purple-500' : 'text-white'
			: 'text-gray-400') + " " + (/*j*/ ctx[28] == 0 ? 'font-bold' : 'font-normal')));

			attr(text_1, "font-size", "10");
			attr(text_1, "fill", "currentColor");
			attr(text_1, "text-anchor", "middle");
			attr(text_1, "dominant-baseline", "middle");
			attr(g, "transform", g_transform_value = "translate(" + /*fretX*/ ctx[5](/*j*/ ctx[28]) + ", 0)");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			if (if_block) if_block.m(g, null);
			append(g, text_1);
			append(text_1, t);

			if (!mounted) {
				dispose = listen(g, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (/*j*/ ctx[28] > 0) if_block.p(ctx, dirty);
			if (dirty & /*strings*/ 16 && t_value !== (t_value = /*note*/ ctx[26].pc.replace("b", "♭") + "")) set_data(t, t_value);

			if (dirty & /*strings, position*/ 17 && text_1_class_value !== (text_1_class_value = "" + ((/*note*/ ctx[26].interval && !/*position*/ ctx[0] || /*noteInPosition*/ ctx[10](/*note*/ ctx[26], /*position*/ ctx[0])
			? /*j*/ ctx[28] == 0 ? 'text-purple-500' : 'text-white'
			: 'text-gray-400') + " " + (/*j*/ ctx[28] == 0 ? 'font-bold' : 'font-normal')))) {
				attr(text_1, "class", text_1_class_value);
			}

			if (dirty & /*fretX*/ 32 && g_transform_value !== (g_transform_value = "translate(" + /*fretX*/ ctx[5](/*j*/ ctx[28]) + ", 0)")) {
				attr(g, "transform", g_transform_value);
			}
		},
		d(detaching) {
			if (detaching) detach(g);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (111:4) {#each strings as str, i}
function create_each_block_1(ctx) {
	let g;
	let line;
	let line_x__value;
	let line_x__value_1;
	let line_stroke_width_value;
	let g_transform_value;
	let each_value_2 = /*str*/ ctx[24];
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			g = svg_element("g");
			line = svg_element("line");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(line, "x1", line_x__value = /*fretX*/ ctx[5](1));
			attr(line, "x2", line_x__value_1 = width - /*margin*/ ctx[8].right);
			attr(line, "stroke", "currentColor");
			attr(line, "class", "text-gray-100");
			attr(line, "stroke-width", line_stroke_width_value = /*lineW*/ ctx[7](/*i*/ ctx[23]));
			attr(g, "transform", g_transform_value = "translate(" + /*margin*/ ctx[8].left + ", " + /*strY*/ ctx[6](/*i*/ ctx[23]) + ")");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			append(g, line);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*fretX*/ 32 && line_x__value !== (line_x__value = /*fretX*/ ctx[5](1))) {
				attr(line, "x1", line_x__value);
			}

			if (dirty & /*lineW*/ 128 && line_stroke_width_value !== (line_stroke_width_value = /*lineW*/ ctx[7](/*i*/ ctx[23]))) {
				attr(line, "stroke-width", line_stroke_width_value);
			}

			if (dirty & /*fretX, play, strings, position, noteInPosition, classesForNote, notes*/ 7219) {
				each_value_2 = /*str*/ ctx[24];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (dirty & /*strY*/ 64 && g_transform_value !== (g_transform_value = "translate(" + /*margin*/ ctx[8].left + ", " + /*strY*/ ctx[6](/*i*/ ctx[23]) + ")")) {
				attr(g, "transform", g_transform_value);
			}
		},
		d(detaching) {
			if (detaching) detach(g);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (168:8) {#if getsFretMarker(i)}
function create_if_block(ctx) {
	let circle;
	let circle_cy_value;

	return {
		c() {
			circle = svg_element("circle");
			attr(circle, "cx", "10");
			attr(circle, "cy", circle_cy_value = /*height*/ ctx[2] - /*margin*/ ctx[8].bottom + 10);
			attr(circle, "r", "3");
			attr(circle, "fill", "currentColor");
			attr(circle, "class", "text-gray-400");
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*height*/ 4 && circle_cy_value !== (circle_cy_value = /*height*/ ctx[2] - /*margin*/ ctx[8].bottom + 10)) {
				attr(circle, "cy", circle_cy_value);
			}
		},
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (150:4) {#each Array(fb.count()) as _, i}
function create_each_block(ctx) {
	let g;
	let text_1;
	let t_value = /*i*/ ctx[23] + 1 + "";
	let t;
	let rect;
	let rect_x_value;
	let rect_height_value;
	let rect_class_value;
	let show_if = /*getsFretMarker*/ ctx[9](/*i*/ ctx[23]);
	let g_transform_value;
	let if_block = show_if && create_if_block(ctx);

	return {
		c() {
			g = svg_element("g");
			text_1 = svg_element("text");
			t = text(t_value);
			rect = svg_element("rect");
			if (if_block) if_block.c();
			attr(text_1, "dx", "10");
			attr(text_1, "fill", "currentColor");
			attr(text_1, "class", "text-black");
			attr(text_1, "font-size", "10");
			attr(text_1, "text-anchor", "middle");
			attr(rect, "rx", "2");
			attr(rect, "x", rect_x_value = /*fretX*/ ctx[5].step() / 1.45);
			attr(rect, "y", "20");
			attr(rect, "height", rect_height_value = /*height*/ ctx[2] - /*margin*/ ctx[8].bottom - 20);
			attr(rect, "fill", "currentColor");

			attr(rect, "class", rect_class_value = /*i*/ ctx[23] + 1 === 11
			? "text-gray-900"
			: "text-gray-400");

			attr(rect, "width", "3");
			attr(g, "transform", g_transform_value = "translate(" + /*fretX*/ ctx[5](/*i*/ ctx[23] + 1) + ", " + (/*margin*/ ctx[8].top - 30) + ")");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			append(g, text_1);
			append(text_1, t);
			append(g, rect);
			if (if_block) if_block.m(g, null);
		},
		p(ctx, dirty) {
			if (dirty & /*fretX*/ 32 && rect_x_value !== (rect_x_value = /*fretX*/ ctx[5].step() / 1.45)) {
				attr(rect, "x", rect_x_value);
			}

			if (dirty & /*height*/ 4 && rect_height_value !== (rect_height_value = /*height*/ ctx[2] - /*margin*/ ctx[8].bottom - 20)) {
				attr(rect, "height", rect_height_value);
			}

			if (show_if) if_block.p(ctx, dirty);

			if (dirty & /*fretX*/ 32 && g_transform_value !== (g_transform_value = "translate(" + /*fretX*/ ctx[5](/*i*/ ctx[23] + 1) + ", " + (/*margin*/ ctx[8].top - 30) + ")")) {
				attr(g, "transform", g_transform_value);
			}
		},
		d(detaching) {
			if (detaching) detach(g);
			if (if_block) if_block.d();
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let svg0;
	let path;
	let t0;
	let t1;
	let svg1;
	let each0_anchor;
	let svg1_viewBox_value;
	let mounted;
	let dispose;
	let each_value_1 = /*strings*/ ctx[4];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = Array(/*fb*/ ctx[3].count());
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			svg0 = svg_element("svg");
			path = svg_element("path");
			t0 = text("\n    Play notes");
			t1 = space();
			svg1 = svg_element("svg");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(path, "fill-rule", "evenodd");
			attr(path, "d", "M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z");
			attr(path, "clip-rule", "evenodd");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "viewBox", "0 0 20 20");
			attr(svg0, "fill", "currentColor");
			attr(svg0, "class", "w-6 h-6 mr-1");
			attr(div0, "class", "flex items-center mt-2 ml-2");
			attr(svg1, "viewBox", svg1_viewBox_value = "0 0 " + width + " " + /*height*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, svg0);
			append(svg0, path);
			append(div0, t0);
			append(div1, t1);
			append(div1, svg1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(svg1, null);
			}

			append(svg1, each0_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svg1, null);
			}

			if (!mounted) {
				dispose = listen(svg0, "click", /*playNotes*/ ctx[13]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*margin, strY, strings, fretX, play, position, noteInPosition, classesForNote, notes, width, lineW*/ 7667) {
				each_value_1 = /*strings*/ ctx[4];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(svg1, each0_anchor);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*fretX, margin, height, getsFretMarker, fb*/ 812) {
				each_value = Array(/*fb*/ ctx[3].count());
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(svg1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*height*/ 4 && svg1_viewBox_value !== (svg1_viewBox_value = "0 0 " + width + " " + /*height*/ ctx[2])) {
				attr(svg1, "viewBox", svg1_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

const width = 1200;
let defaultHeight = 240;

function instance($$self, $$props, $$invalidate) {
	let $bpm;
	component_subscribe($$self, bpm, $$value => $$invalidate(19, $bpm = $$value));
	let { scale = null } = $$props;
	let { system = tnps } = $$props;
	let { position = null } = $$props;
	let { tuning } = $$props;
	let { notes = null } = $$props;
	const { player } = getContext("app");
	const margin = { top: 45, right: 10, bottom: 35, left: 10 };
	let height;
	let fb, fbnotes, strings, fretX, strY, lineW;
	const getsFretMarker = i => (i + 1) % 2 !== 0 && ![1, 11, 13].includes(i + 1) || i + 1 == 12;
	const noteInPosition = (note, position) => position && note.positions && note.positions.includes(+position);

	const classesForNote = (note, notes) => {
		const names = notes.map(n => n.name);

		if (note.interval === "1P") {
			return names.includes(note.name)
			? "text-pink-700"
			: "text-black";
		}

		if (note.interval) {
			return names.includes(note.name)
			? "text-gray-600"
			: "text-purple-800";
		}

		return "text-white";
	};

	async function play(n) {
		console.log(n);
		await player.play([n.midi]);
	}

	async function playNotes(event) {
		const nstrings = strings.map(s => s.filter(n => {
			return noteInPosition(n, position);
		}).map(n => {
			return n.midi;
		}));

		let o1 = [];
		let o2 = [];
		console.log(nstrings);

		nstrings.forEach(s => {
			o1 = o1.concat(s.slice(0, 3).reverse());
			o2 = o2.concat(s.slice(3).reverse());
		});

		while (o1.length > 0) {
			const n = o1.pop();
			await delay(60 / $bpm * 1000);
			await player.play([n]);
		}
	}

	const click_handler = note => play(note);

	$$self.$$set = $$props => {
		if ('scale' in $$props) $$invalidate(14, scale = $$props.scale);
		if ('system' in $$props) $$invalidate(15, system = $$props.system);
		if ('position' in $$props) $$invalidate(0, position = $$props.position);
		if ('tuning' in $$props) $$invalidate(16, tuning = $$props.tuning);
		if ('notes' in $$props) $$invalidate(1, notes = $$props.notes);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*scale, position, tuning, fb, system, fbnotes, height, strings*/ 245789) {
			$: if ((scale || position) && tuning) {
				const sharps = scale.notes().some(n => n.acc === "#");
				$$invalidate(2, height = defaultHeight + (tuning.length - 6) * 32);
				$$invalidate(3, fb = frets(tuning, 2, sharps));
				$$invalidate(17, fbnotes = fb.notes());
				$$invalidate(4, strings = system(fbnotes, scale).reverse());
				$$invalidate(5, fretX = scaleBand().domain(range(fb.count() + 1)).range([margin.left, width - margin.right]));
				$$invalidate(6, strY = scalePoint().domain(range(fbnotes.length)).range([margin.top, height - margin.bottom]));
				$$invalidate(7, lineW = scaleLinear().domain([0, strings.length]).range([1, 4]));
			}
		}
	};

	return [
		position,
		notes,
		height,
		fb,
		strings,
		fretX,
		strY,
		lineW,
		margin,
		getsFretMarker,
		noteInPosition,
		classesForNote,
		play,
		playNotes,
		scale,
		system,
		tuning,
		fbnotes,
		click_handler
	];
}

class FretBoard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			scale: 14,
			system: 15,
			position: 0,
			tuning: 16,
			notes: 1
		});
	}
}

export default FretBoard;